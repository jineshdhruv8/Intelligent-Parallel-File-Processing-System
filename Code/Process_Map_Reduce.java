import java.io.*;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Scanner;


/*
 *  @author    Jinesh Dhruv
 *  @author    Nisha Bhnaushali
 *
 * MapReduce Implementation
 * This program will be a mapper or reducer.
 * It will sort the file if it is mapper or
 * merger all the results generated by mapper if it is reducer
 *
 */
public class Process_Map_Reduce extends Thread {
    Colors colors=new Colors();
    static String client_ip;
    static int id; // process_id
    static int port;
    static int[] new_array; // for merge sort
    static int[] elements; // for merge sort
    static ArrayList<Integer> sorted_numbers; // for merge sort result
    static int count_keys=0;
    static int mapper_count=0;
    static HashMap<Integer,ArrayList<Integer>> key_value=new HashMap<Integer,ArrayList<Integer>>(); // dictionary for key value pair of file info
    static ArrayList<Integer> final_result=new ArrayList<Integer>();
    static String reducer_ip="",master_ip="";
    static int reducer_port=0,master_port=0;
    static String slow_process_ip="";
    static int slow_process_port=0;
    String type="";
    Socket socket;
    int key=-1;

    // Constructors
    Process_Map_Reduce(Socket socket){
        this.socket=socket;
    }
    Process_Map_Reduce(String type){
        this.type=type;
    }
    Process_Map_Reduce(String type,int port){
        this.type=type;
        this.port=port;
    }
    Process_Map_Reduce(){}

    /**
     * This function will reinitialize all the necessary parameters needed for sorting
     * next file
     */
    void reinitialize() {
        sorted_numbers = new ArrayList<Integer>(); // for merge sort result
        key_value = new HashMap<Integer, ArrayList<Integer>>();
        count_keys=0;
        mapper_count=0;
        final_result=new ArrayList<Integer>();
    }


    public void run(){
        try{
            if(type.equals("reducer")){ // This thread will start merging of the results from the mapper
                long start_time=System.currentTimeMillis();
                System.out.println();
                System.out.println(colors.ANSI_BLUE+"Merging results from all Mapper based on key_value pair");
                merge_all_results();
                long end_time=System.currentTimeMillis();
                System.out.println("Time for Merging = " + (end_time - start_time)+" ms"+colors.ANSI_RESET);
                System.out.println();
                send_the_result_to_master(final_result, "success");
                reinitialize();
            }else if (type.equals("server")){
                // new connection
                ServerSocket serverSocket=new ServerSocket(port);
                while (true){
                    Socket socket=serverSocket.accept();
                    Thread t=new Thread(new Process_Map_Reduce(socket),"obj2");
                    t.start();
                    t.join();
                }
            }else{
                ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
                String result=inputStream.readUTF();
                if(result.equals("job")){
                    key=inputStream.read();
                    reducer_ip=inputStream.readUTF();
                    reducer_port=inputStream.readInt();
                    long start_time=System.currentTimeMillis();
                    ArrayList<Integer> final_result=(ArrayList<Integer>)inputStream.readObject();
                    long end_time=System.currentTimeMillis();
                    start_time=System.currentTimeMillis();
                    System.out.print(colors.ANSI_GREEN);
                    System.out.println("This is Mapper Machine");
                    System.out.println("Input size = " + final_result.size());
                    Sorting(final_result);
                    end_time=System.currentTimeMillis();
                    System.out.println("Time to complete work = " + (end_time - start_time)+" ms"+colors.ANSI_RESET);
                    System.out.println();
                    send_object(sorted_numbers,reducer_ip,reducer_port,"map",key);
                }else if(result.equals("bootstrap")){
                    System.out.println("This is reducer Machine");
                    count_keys=inputStream.read();
                    mapper_count=count_keys;
                    reducer_ip=inputStream.readUTF();
                    reducer_port=inputStream.readInt();
                    master_ip=inputStream.readUTF();
                    master_port=inputStream.readInt();
                    ArrayList<Integer> temp_array=(ArrayList<Integer>)inputStream.readObject();
                }else if(result.equals("map")){
                    key=inputStream.readInt();
                    String temp_ip_port[]=inputStream.readUTF().split(" ");
                    ArrayList<Integer> temp=(ArrayList<Integer>)inputStream.readObject();
                    key_value.put(key,temp);
                    count_keys-=1;
                    if(count_keys==0){
                        slow_process_ip=temp_ip_port[0];
                        slow_process_port= Integer.parseInt(temp_ip_port[1]);
                        System.out.println(colors.ANSI_RED+"Slow mapper_ip = "+slow_process_ip);
                        System.out.println("Received all results from all mappers"+colors.ANSI_RESET);
                        Thread t3=new Thread(new Process_Map_Reduce("reducer"),"obj3");
                        t3.start();
                        sleep(1000);
                    }
                }

                inputStream.close();
                socket.close();
            }
        }catch (Exception e){
            e.printStackTrace();
            System.out.println("Error = "+e);
        }
    }


    /**
     * This function will merger all the results from mapper in the appropriate order
     */
    void merge_all_results(){
        for(int i=1;i<=mapper_count;i++){
            ArrayList<Integer> value = key_value.get(i);
            for (int j = 0; j <value.size() ; j++) {
                final_result.add(value.get(j));
            }
        }
    }




    /**
     * This function will initiate the sorting process
     * @param numbers  It contains the input to be sorted
     */
    public void Sorting(ArrayList<Integer> numbers) {
        elements = new int[numbers.size()];
        new_array = new int[numbers.size()];
        sorted_numbers = new ArrayList<Integer>();
        moveToArray(numbers, elements);
        mergeSort(elements, 0, elements.length - 1);
        moveToArrayList(sorted_numbers, new_array);
    }

    /**
     * This function will arrange the input in the format required for sorting
     * @param sorted_numbers    It contains the number list to be sorted
     * @param new_array         Reference array for storing intermediate output
     */
    public void moveToArrayList(ArrayList<Integer> sorted_numbers, int[] new_array) {
        for (int count = 0; count < new_array.length; count++) {
            sorted_numbers.add(new_array[count]);
        }
    }

    /**
     * This function will arrange the sorting output in the format required for reducer
     * @param numbers   It stores the intermediate result
     * @param elements  It stores the final result of sorting
     */
    public void moveToArray(ArrayList<Integer> numbers, int[] elements) {
        for (int count = 0; count < numbers.size(); count++) {
            elements[count] = numbers.get(count);
        }
    }

    /**
     * This function starts the merge sort the two sorted list
     * @param elements  input elements
     * @param low       lowest index in the list
     * @param high      highest index in the list
     */
    public static void mergeSort(int[] elements, int low, int high) {
        if (low < high) {
            int middle = (low + high) / 2;
            mergeSort(elements, low, middle);
            mergeSort(elements, middle + 1, high);
            mergeParts(elements, low, middle, high);
        }
    }

    /**
     * This function merges the result of the two sorted list
     * @param elements
     * @param low       lowest index in the list
     * @param middle    Partition index
     * @param high      highest index in the list
     *
     */
    public static void mergeParts(int[] elements, int low, int middle, int high) {
        new_array = new int[elements.length];
        int first_index = low;
        int middle_index = middle + 1;
        int last_index = low;
        while (first_index <= middle && middle_index <= high) {
            if (elements[first_index] <= elements[middle_index]) {
                new_array[last_index] = elements[first_index];
                first_index++;
            } else {
                new_array[last_index] = elements[middle_index];
                middle_index++;
            }
            last_index++;
        }
        while (first_index <= middle) {
            new_array[last_index] = elements[first_index];
            last_index++;
            first_index++;
        }
        while (middle_index <= high) {
            new_array[last_index] = elements[middle_index];
            last_index++;
            middle_index++;
        }
        for (int counter = low; counter <= high; counter++) {
            elements[counter] = new_array[counter];
        }
    }


    /**
     *
     * @param temp   It contains the arraylist which is to be displayed
     */
    void display(ArrayList<Integer> temp){
        for (int i = 0; i <temp.size() ; i++) {
            System.out.print(temp.get(i)+" ");
        }
        System.out.println();
    }


    /**
     * This function will send the object to other servers for map-reduce job
     * @param temp          object that needs to be send
     * @param ip            ipaddress of the server to send
     * @param temp_port     port of the server to send
     * @param msg           message to send
     */
    void send_object(ArrayList<Integer> temp, String ip, int temp_port, String msg,int key){
        try{
            Socket socket=new Socket(ip,temp_port);
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeUTF(msg);
            outputStream.writeInt(key);
            outputStream.writeUTF(client_ip+" "+port);
            outputStream.writeObject(temp);

            outputStream.flush();
            outputStream.close();
        }catch (Exception e){
            if(e.getMessage().contains("refused")){
                //send_request(map.get(process_list.get(4)),port_map.get(process_list.get(4)),id,"election",4);
                System.out.println("Process " + ip + " is down");
            }else{
                System.out.println("Error = "+e);
                e.printStackTrace();
            }
        }
    }


    /**
     *This function will send the result after merging to master server
     * @param temp_list     It contains the Final result
     * @param msg           Unique message for identification of this result
     */
    void send_the_result_to_master(ArrayList<Integer> temp_list,String msg){
        try{
            Socket socket=new Socket(master_ip,master_port);
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeUTF(msg);
            outputStream.writeUTF(slow_process_ip+" "+slow_process_port);
            outputStream.writeObject(temp_list);
            outputStream.flush();
            outputStream.close();
        }catch (Exception e){
            if(e.getMessage().contains("refused")){
                System.out.println("Process " + master_ip + " is down");
            }else{
                System.out.println("Error = "+e);
                e.printStackTrace();
            }
        }

    }

    /**
     * @param args command line arguments (ignored)
     * @throws UnknownHostException, InterruptedException
     */
    public static void main(String[] args) throws InterruptedException, UnknownHostException {
        InetAddress inetAddress = InetAddress.getLocalHost();
        client_ip = inetAddress.getHostAddress();
        System.out.println("Machine ip = "+client_ip+" & Machine Name = "+inetAddress.getHostName());
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(); // fetch process id from user
        // based on process id, initialize everything
        if(n==1){
            port=9000;
            id=1;
        }else if(n==2){
            port=10000;
            id=2;
        }else if(n==3){
            port=11000;
            id=3;
        }else if(n==4){
            port=12000;
            id=4;
        }else if(n==5){
            port=13000;
            id=5;
        }

        // start the server thread
        Thread t10=new Thread(new Process_Map_Reduce("server",port),"obj1");
        t10.start();
        System.out.println();
        sleep(2000);
    }
    
}
